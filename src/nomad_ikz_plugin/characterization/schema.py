#
# Copyright The NOMAD Authors.
#
# This file is part of NOMAD. See https://nomad-lab.eu for further info.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
from collections.abc import Callable
from typing import TYPE_CHECKING, Any

import numpy as np
import plotly.express as px
from nomad.config import config
from nomad.datamodel.data import ArchiveSection, EntryData
from nomad.datamodel.metainfo.annotations import (
    ELNAnnotation,
    Filter,
    SectionProperties,
)
from nomad.datamodel.metainfo.basesections import (
    Measurement,
    MeasurementResult,
    ReadableIdentifiers,
)
from nomad.datamodel.metainfo.plot import (
    PlotlyFigure,
    PlotSection,
)
from nomad.metainfo import Datetime, MEnum, Quantity, SchemaPackage, Section, SubSection
from nomad_measurements.transmission.schema import (
    CrystallographicTransmissionSampleReference,
    ELNUVVisNirTransmission,
    UVVisNirTransmissionResult,
    UVVisNirTransmissionSettings,
)
from nomad_measurements.utils import merge_sections

from nomad_ikz_plugin.characterization.readers import reader_ir_brucker
from nomad_ikz_plugin.general.schema import (
    IKZCategory,
    SubstratePreparationStep,
)

if TYPE_CHECKING:
    from nomad.datamodel.datamodel import EntryArchive
    from structlog.stdlib import BoundLogger


configuration = config.get_plugin_entry_point(
    'nomad_ikz_plugin.characterization:schema'
)

m_package = SchemaPackage(
    aliases=[
        'ikz_plugin.characterization.schema',
    ],
)


class AFMresults(MeasurementResult):
    """
    The results of an AFM measurement
    """

    roughness = Quantity(
        type=np.float64,
        description='RMS roughness value obtained by AFM',
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'picometer'},
        unit='picometer',
    )
    surface_features = Quantity(
        type=MEnum(
            [
                'Step Flow',
                'Step Bunching',
                '2D Island',
                'Grains',
                'Holes',
                'Stripes',
                'Other',
            ]
        ),
        a_eln={'component': 'EnumEditQuantity'},
    )
    additional_surface_features = Quantity(
        type=str,
        description='specified surface features e.g. shape/size of holes or islands',
        a_eln={'component': 'StringEditQuantity'},
    )
    scale = Quantity(
        type=np.float64,
        description='scale bar of the image, to be multiplied by 5 to know the image size',
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'nanometer'},
        unit='nanometer',
    )
    image = Quantity(
        type=str,
        description='image showing the height measurement points',
        a_browser={'adaptor': 'RawFileAdaptor'},
        a_eln={'component': 'FileEditQuantity'},
    )
    crop_image = Quantity(
        type=str,
        description='crop image ready to be used for AI-based analysis',
        a_browser={'adaptor': 'RawFileAdaptor'},
        a_eln={'component': 'FileEditQuantity'},
    )


class AFMmeasurement(Measurement, SubstratePreparationStep, EntryData):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section(
        a_eln={'hide': ['steps']},
        categories=[IKZCategory],
        label='AFM',
    )

    method = Quantity(
        type=str,
        default='AFM (IKZ MOVPE)',
    )
    description = Quantity(
        type=str,
        a_eln={'component': 'StringEditQuantity'},
    )
    datetime = Quantity(
        type=Datetime,
        a_eln={'component': 'DateTimeEditQuantity'},
    )
    results = SubSection(
        section_def=AFMresults,
        repeats=True,
    )


class LiMiresults(MeasurementResult):
    """
    The results of a Light Microscope measurement
    """

    image = Quantity(
        type=str,
        description='image showing the measurement',
        a_browser={'adaptor': 'RawFileAdaptor'},
        a_eln={'component': 'FileEditQuantity'},
    )
    crop_image = Quantity(
        type=str,
        description='crop image ready to be used for AI-based analysis',
        a_browser={'adaptor': 'RawFileAdaptor'},
        a_eln={'component': 'FileEditQuantity'},
    )
    scale = Quantity(
        type=np.float64,
        description='scale of the image',
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'micrometer'},
        unit='micrometer',
    )


class LightMicroscope(Measurement, SubstratePreparationStep, EntryData):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section(
        a_eln={'hide': ['steps']},
        categories=[IKZCategory],
        label='Light Microscope',
    )
    method = Quantity(
        type=str,
        default='Light Microscope (MOVPE IKZ)',
    )
    datetime = Quantity(
        type=Datetime,
        a_eln={'component': 'DateTimeEditQuantity'},
    )
    results = SubSection(
        section_def=LiMiresults,
        repeats=True,
    )


class IKZUVVisNirTransmissionSettings(UVVisNirTransmissionSettings):
    """
    A specialized section for IKZ based on the `UVVisNirTransmissionSettings` section.
    """

    ordinate_type = Quantity(
        type=MEnum(['%T', 'A']),
        description=(
            'Specifies whether the ordinate (y-axis) of the measurement data is '
            'percent transmittance (%T) or absorbance (A).'
        ),
        a_eln={'component': 'EnumEditQuantity'},
    )


class IKZUVVisNirTransmissionResult(UVVisNirTransmissionResult):
    """
    A specialized section for IKZ based on the `UVVisNirTransmissionResult` section.
    """

    m_def = Section(
        a_eln=ELNAnnotation(
            properties=SectionProperties(
                order=[
                    'transmittance',
                    'absorbance',
                    'wavelength',
                    'extinction_coefficient',
                ],
                visible=Filter(
                    exclude=[
                        'array_index',
                    ],
                ),
            )
        )
    )
    extinction_coefficient = Quantity(
        type=np.float64,
        description=(
            'Extinction coefficient calculated from transmittance and sample thickness '
            'values: -log(T)/L. The coefficient includes the effects of '
            'absorption, reflection, and scattering.'
        ),
        shape=['*'],
        unit='1/m',
        a_plot={'x': 'array_index', 'y': 'extinction_coefficient'},
    )

    def generate_plots(self) -> list[PlotlyFigure]:
        """
        Extends UVVisNirTransmissionResult.generate_plots() method to include the plotly
        figures for the `IKZUVVisNirTransmissionResult` section.

        Returns:
            list[PlotlyFigure]: The plotly figures.
        """
        figures = super().generate_plots()
        if self.wavelength is None:
            return figures

        # generate plot for extinction coefficient
        if self.extinction_coefficient is None:
            return figures

        x = self.wavelength.to('nm').magnitude
        x_label = 'Wavelength'
        xaxis_title = x_label + ' (nm)'

        y = self.extinction_coefficient.to('1/cm').magnitude
        y_label = 'Extinction coefficient'
        yaxis_title = y_label + ' (1/cm)'

        line_linear = px.line(x=x, y=y)

        line_linear.update_layout(
            title=f'{y_label} over {x_label}',
            xaxis_title=xaxis_title,
            yaxis_title=yaxis_title,
            xaxis=dict(
                fixedrange=False,
            ),
            yaxis=dict(
                fixedrange=False,
            ),
            template='plotly_white',
        )

        figures.append(
            PlotlyFigure(
                label=f'{y_label} linear plot',
                figure=line_linear.to_plotly_json(),
            ),
        )

        return figures

    def calculate_extinction_coefficient(self, archive, logger):
        """
        Calculate the extinction coefficient from the transmittance and geometric path
        length of the sample. The formula used is: -log( T[%] / 100 ) / L.

        Args:
            archive (EntryArchive): The archive containing the section.
            logger (BoundLogger): A structlog logger.
        """
        self.extinction_coefficient = None
        if not archive.data.samples:
            logger.warning(
                'Cannot calculate extinction coefficient as sample not found.'
            )
            return
        if not archive.data.samples[0].geometric_path_length:
            logger.warning(
                'Cannot calculate extinction coefficient as the geometric path length '
                'of the sample is not found or the value is 0.'
            )
            return

        path_length = archive.data.samples[0].geometric_path_length
        if self.transmittance is not None:
            extinction_coeff = -np.log(self.transmittance) / path_length
            self.extinction_coefficient = extinction_coeff

    def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
        """
        The normalizer for the `IKZUVVisNirTransmissionResult` class.

        Args:
            archive (EntryArchive): The archive containing the section that is being
            normalized.
            logger (BoundLogger): A structlog logger.
        """
        super().normalize(archive, logger)
        self.calculate_extinction_coefficient(archive, logger)


class IKZELNUVVisNirTransmission(ELNUVVisNirTransmission):
    """
    A specialized section for IKZ based on the `ELNUVVisNirTransmission` section.
    """

    m_def = Section(
        categories=[IKZCategory],
        label='IKZ UV-Vis-NIR Transmission',
        a_template={
            'measurement_identifiers': {},
        },
    )
    results = SubSection(
        section_def=IKZUVVisNirTransmissionResult,
        repeats=True,
    )
    transmission_settings = SubSection(
        section_def=IKZUVVisNirTransmissionSettings,
    )

    def write_transmission_data(self, transmission, data_dict, archive, logger):
        """
        Specialized method to write the transmission data for the IKZ plugin. The method
        overrides the `write_transmission_data` method of the parent
        `ELNUVVisNirTransmission` class.
        """
        super().write_transmission_data(transmission, data_dict, archive, logger)
        if data_dict['ordinate_type'] in ['%T', 'A']:
            transmission.transmission_settings.ordinate_type = data_dict.get(
                'ordinate_type'
            )


class IRTransmissionSettings(ArchiveSection):
    """
    A section defining the schema for IR transmission measurement settings.
    """

    aperture_setting = Quantity(
        type=float,
        unit='m',
        description='Description needed.',
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'micrometer'},
    )
    beamsplitter_setting = Quantity(
        type=str,
        description='Description needed.',
        a_eln={'component': 'StringEditQuantity'},
    )
    measurement_channel = Quantity(
        type=str,
        description='Description needed.',
        a_eln={'component': 'StringEditQuantity'},
    )
    detector_setting = Quantity(
        type=str,
        description='Description needed.',
        a_eln={'component': 'StringEditQuantity'},
    )
    high_pass_filter = Quantity(
        type=str,
        description='Description needed.',
        a_eln={'component': 'StringEditQuantity'},
    )
    low_pass_filter = Quantity(
        type=str,
        description='Description needed.',
        a_eln={'component': 'StringEditQuantity'},
    )
    variable_low_pass_filter = Quantity(
        type=float,
        unit='m^-1',
        description='Description needed.',
        a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'cm^-1'},
    )
    optical_filter_setting = Quantity(
        type=str,
        description='Description needed.',
        a_eln={'component': 'StringEditQuantity'},
    )
    preamplifier_gain = Quantity(
        type=float,
        unit='dimensionless',
        description='Description needed.',
        a_eln={'component': 'NumberEditQuantity'},
    )
    source_setting = Quantity(
        type=str,
        description='Description needed.',
        a_eln={'component': 'StringEditQuantity'},
    )
    scanner_velocity = Quantity(
        type=str,
        description='Description needed.',
        a_eln={'component': 'StringEditQuantity'},
    )
    acquisition_mode = Quantity(
        type=str,
        description='Description needed.',
        a_eln={'component': 'StringEditQuantity'},
    )
    wanted_high_frequency_limit = Quantity(
        type=str,
        description='Description needed.',
        a_eln={'component': 'StringEditQuantity'},
    )
    wanted_low_frequency_limit = Quantity(
        type=str,
        description='Description needed.',
        a_eln={'component': 'StringEditQuantity'},
    )
    sample_scans = Quantity(
        type=str,
        description='Description needed.',
        a_eln={'component': 'StringEditQuantity'},
    )
    result_spectrum = Quantity(
        type=str,
        description='Description needed.',
        a_eln={'component': 'StringEditQuantity'},
    )
    resolution = Quantity(
        type=str,
        description='Description needed.',
        a_eln={'component': 'StringEditQuantity'},
    )


class IRTransmissionResult(UVVisNirTransmissionResult):
    """
    A section defining the schema for IR transmission measurement results.
    """

    m_def = Section(
        a_eln=ELNAnnotation(
            properties=SectionProperties(
                order=[
                    'absorbance',
                    'wavelength',
                    'transmittance',
                ],
                visible=Filter(
                    exclude=[
                        'array_index',
                    ],
                ),
            )
        )
    )


class IRTransmission(Measurement):
    """
    A section defining the schema for IR transmission measurements.
    """

    m_def = Section()

    user = Quantity(
        type=str,
        description='Name of user or analyst.',
        a_eln={'component': 'StringEditQuantity'},
    )

    method = Quantity(
        type=str,
        default='IR Transmission Spectrophotometry',
    )

    samples = SubSection(
        section_def=CrystallographicTransmissionSampleReference,
        description='A list of all the samples measured during the measurement.',
        repeats=True,
    )
    results = SubSection(
        section_def=IRTransmissionResult,
        description='The result of the IR spectroscopy measurement.',
        repeats=True,
    )

    transmission_settings = SubSection(
        section_def=IRTransmissionSettings,
    )


class ELNIRTransmission(IRTransmission, EntryData, PlotSection):
    """
    An EntryData section for IRTransmission that allows user input and plotting.
    """

    m_def = Section(
        label='IR Transmission',
        a_template={
            'measurement_identifiers': {},
        },
    )

    measurement_identifiers = SubSection(
        section_def=ReadableIdentifiers,
    )
    data_file = Quantity(
        type=str,
        description='The data file containing the IR transmission measurement data.',
        a_browser={'adaptor': 'RawFileAdaptor'},
        a_eln={'component': 'FileEditQuantity'},
    )

    def get_read_write_functions(self) -> tuple[Callable, Callable]:
        """
        Method for getting the correct read and write functions for the current data
        file.

        Returns:
            tuple[Callable, Callable]: The read, write functions.
        """
        if self.data_file.endswith('.0'):
            return reader_ir_brucker, self.write_transmission_data
        return None, None

    def write_transmission_data(  # noqa: PLR0912, PLR0915
        self,
        transmission: IRTransmission,
        data_dict: dict[str, Any],
        archive: 'EntryArchive',
        logger: 'BoundLogger',
    ) -> None:
        """
        Writes the IR transmission data to the archive.

        Args:
            archive (EntryArchive): The archive to write the data to.
            logger (BoundLogger): A structlog logger.
        """
        transmission.user = data_dict['analyst_name']
        transmission.datetime = data_dict['start_datetime']

        # populate results
        transmission.m_setdefault('results/0')
        if data_dict['ordinate_type'] == 'Absorbance':
            transmission.results[0].absorbance = data_dict['measured_ordinate']
        elif data_dict['ordinate_type'] == 'Transmittance':
            transmission.results[0].transmittance = data_dict['measured_ordinate']
        transmission.results[0].wavelength = data_dict['measured_wavelength']
        transmission.results[0].normalize(archive, logger)

        # populate settings
        transmission.m_setdefault('transmission_settings')
        for key, value in data_dict.items():
            if hasattr(transmission.transmission_settings, key):
                setattr(transmission.transmission_settings, key, value)

    def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
        """
        Normalizes the IR transmission data in the archive.

        Args:
            archive (EntryArchive): The archive containing the section that is being
            normalized.
            logger (BoundLogger): A structlog logger.
        """
        if self.data_file is not None:
            read_function, write_function = self.get_read_write_functions()
            if read_function is None or write_function is None:
                logger.warning(
                    f'No compatible reader found for the file: "{self.data_file}".'
                )
            else:
                with archive.m_context.raw_file(self.data_file) as file:
                    data_dict = read_function(file.name, logger)
                if data_dict:
                    # self.connect_instrument(data_dict, archive, logger)
                    transmission = self.m_def.section_cls()
                    write_function(transmission, data_dict, archive, logger)
                    merge_sections(self, transmission, logger)
        super().normalize(archive, logger)

        if not self.results:
            return

        self.figures = self.results[0].generate_plots()


m_package.__init_metainfo__()
